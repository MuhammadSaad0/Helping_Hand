# Customer and Plan Management Database

## Overview

This project implements a robust PostgreSQL database schema for managing customers, subscription plans, and usage analytics. It's designed to support a SaaS (Software as a Service) application with features like plan management, customer tracking, and usage monitoring.

## Features

- **Customer Management**: Track customer information, including email and metadata.
- **Plan Management**: Define and manage subscription plans with pricing and resources.
- **Resource Tracking**: Monitor and update customer resource usage.
- **Audit Logging**: Automatically log changes to customer plans and resources.
- **Usage Analytics**: View aggregated data on customer plan usage.
- **Stripe Integration**: Support for Stripe customer and plan IDs.

## Database Schema


```sql
-- Create plans table
CREATE TABLE public.plans (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    name text NOT NULL,
    price decimal(10, 2) NOT NULL,
    benefits jsonb NOT NULL,
    description text,
    price_currency text NOT NULL DEFAULT 'euro',
    stripe_price_id text UNIQUE,
    stripe_plan_id text UNIQUE,
    resources jsonb,
    CONSTRAINT check_price_positive CHECK (price >= 0)
);

-- Create customer table
CREATE TABLE public.customer (
    uuid uuid PRIMARY KEY,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    email varchar(255) NOT NULL UNIQUE,
    metadata jsonb DEFAULT '{}'::jsonb,
    stripe_customer_id text UNIQUE,
    plan_id bigint REFERENCES public.plans(id) ON DELETE SET NULL,
    plan_updated_at timestamptz,
    plan_resources jsonb,
    remaining_resources jsonb
);

-- Create index on plan_id
CREATE INDEX idx_customer_plan_id ON public.customer(plan_id);

-- Function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.customer (uuid, email, metadata)
  VALUES (NEW.id, NEW.email, COALESCE(NEW.raw_user_meta_data, '{}'::jsonb));
  RETURN NEW;
END;
$$;

-- Trigger for new user creation
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION public.handle_new_user();

-- Function to handle user updates
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE public.customer
  SET 
    metadata = COALESCE(NEW.raw_user_meta_data, '{}'::jsonb),
    email = NEW.email,
    updated_at = now()
  WHERE uuid = NEW.id;
  RETURN NEW;
END;
$$;

-- Trigger for user updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW
EXECUTE FUNCTION public.handle_user_update();

-- Function to handle customer plan updates
CREATE OR REPLACE FUNCTION public.handle_customer_plan_update()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    plan_resources_ jsonb;
BEGIN
    IF NEW.plan_id IS DISTINCT FROM OLD.plan_id THEN
        SELECT resources INTO plan_resources_
        FROM public.plans
        WHERE id = NEW.plan_id;

        NEW.plan_resources := plan_resources_;
        NEW.remaining_resources := plan_resources_;
        NEW.plan_updated_at := now();
        NEW.updated_at := now();
    END IF;
    RETURN NEW;
END;
$$;

-- Trigger for customer plan updates
CREATE TRIGGER on_customer_plan_updated
BEFORE UPDATE OF plan_id ON public.customer
FOR EACH ROW
EXECUTE FUNCTION public.handle_customer_plan_update();

-- Enable Row Level Security
ALTER TABLE public.customer ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;

-- Create a table for audit logs
CREATE TABLE public.audit_logs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz NOT NULL DEFAULT now(),
    customer_uuid uuid NOT NULL REFERENCES public.customer(uuid) ON DELETE CASCADE,
    action text NOT NULL,
    old_value jsonb,
    new_value jsonb
);

-- Create an index on the customer_uuid column of the audit_logs table
CREATE INDEX idx_audit_logs_customer_uuid ON public.audit_logs(customer_uuid);

-- Function to log changes to customer plans and resources
CREATE OR REPLACE FUNCTION public.log_customer_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF (OLD.plan_id IS DISTINCT FROM NEW.plan_id) OR 
     (OLD.remaining_resources IS DISTINCT FROM NEW.remaining_resources) THEN
    INSERT INTO public.audit_logs (customer_uuid, action, old_value, new_value)
    VALUES (
      NEW.uuid,
      CASE
        WHEN OLD.plan_id IS DISTINCT FROM NEW.plan_id THEN 'plan_change'
        ELSE 'resource_update'
      END,
      jsonb_build_object(
        'plan_id', OLD.plan_id,
        'remaining_resources', OLD.remaining_resources
      ),
      jsonb_build_object(
        'plan_id', NEW.plan_id,
        'remaining_resources', NEW.remaining_resources
      )
    );
  END IF;
  RETURN NEW;
END;
$$;

-- Trigger for logging customer changes
CREATE TRIGGER on_customer_changes
AFTER UPDATE OF plan_id, remaining_resources ON public.customer
FOR EACH ROW
EXECUTE FUNCTION public.log_customer_changes();

-- Create a view for usage analytics
CREATE OR REPLACE VIEW public.usage_analytics AS
SELECT
  c.uuid,
  c.email,
  p.name AS plan_name,
  p.price AS plan_price,
  c.plan_updated_at,
  c.remaining_resources,
  p.resources AS total_resources
FROM
  public.customer c
LEFT JOIN
  public.plans p ON c.plan_id = p.id;

-- Sample plans data
INSERT INTO public.plans (name, price, benefits, description, resources)
VALUES 
('Basic', 9.99, '["Feature 1", "Feature 2"]', 'Basic plan for starters', '{"api_calls": 1000, "storage_gb": 10}'),
('Pro', 19.99, '["Feature 1", "Feature 2", "Feature 3"]', 'Pro plan for power users', '{"api_calls": 5000, "storage_gb": 50}'),
('Enterprise', 49.99, '["Feature 1", "Feature 2", "Feature 3", "Feature 4"]', 'Enterprise plan for large organizations', '{"api_calls": 20000, "storage_gb": 200}');
```

## Usage

After setup, you can interact with the database using SQL queries. Here are some example operations:

1. Create a new customer:
   ```sql
   INSERT INTO public.customer (uuid, email) VALUES (gen_random_uuid(), 'user@example.com');
   ```

2. Update a customer's plan:
   ```sql
   UPDATE public.customer SET plan_id = 1 WHERE email = 'user@example.com';
   ```

3. View usage analytics:
   ```sql
   SELECT * FROM public.usage_analytics;
   ```

## Maintenance

To clean up the database and remove all created objects, run the following SQL commands:

```sql
-- Drop all objects created in the Customer and Plan Management Database Setup

-- Drop the usage analytics view
DROP VIEW IF EXISTS public.usage_analytics;

-- Drop triggers
DROP TRIGGER IF EXISTS on_customer_changes ON public.customer;
DROP TRIGGER IF EXISTS on_customer_plan_updated ON public.customer;
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Drop functions
DROP FUNCTION IF EXISTS public.log_customer_changes();
DROP FUNCTION IF EXISTS public.handle_customer_plan_update();
DROP FUNCTION IF EXISTS public.handle_user_update();
DROP FUNCTION IF EXISTS public.handle_new_user();

-- Drop indexes
DROP INDEX IF EXISTS public.idx_audit_logs_customer_uuid;
DROP INDEX IF EXISTS public.idx_customer_plan_id;

-- Drop tables
DROP TABLE IF EXISTS public.audit_logs;
DROP TABLE IF EXISTS public.customer;
DROP TABLE IF EXISTS public.plans;

delete from auth.users
```

**Warning**: This will remove all data. Ensure you have backups if needed.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Support

If you encounter any problems or have any questions, please open an issue in this repository.

---

Developed with ❤️ by [Muhammad Talha Zulfiqar/Texagon]
