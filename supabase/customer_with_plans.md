# Customer and Plan Management Database Schema

## Overview

This File contains the SQL schema for a customer and plan management system. The schema is designed to work with a PostgreSQL database and includes tables for customers, plans, and the relationships between them. It also includes functions and triggers to manage user data synchronization with an authentication system.

## Table Structure

### Customers Table

The `customer` table stores information about each customer.

```sql
CREATE TABLE public.customer (
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    uuid uuid NOT NULL,
    email character varying NOT NULL,
    metadata jsonb DEFAULT '[]'::jsonb,
    stripe_customer_id text,
    CONSTRAINT customer_pkey PRIMARY KEY (uuid),
    CONSTRAINT customer_uuid_fkey FOREIGN KEY (uuid) REFERENCES auth.users (id) ON DELETE CASCADE
);
```

- `created_at`: Timestamp of when the customer was created
- `uuid`: Unique identifier for the customer (linked to auth.users)
- `email`: Customer's email address
- `metadata`: JSON field for additional customer data
- `stripe_customer_id`: Stripe customer ID for payment processing

### Plans Table

The `plans` table stores information about different subscription plans.

```sql
CREATE TABLE public.plans (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text,
    price double precision,
    benefits jsonb NOT NULL,
    description text,
    price_currency text DEFAULT 'euro'::text,
    stripe_price_id text,
    stripe_plan_id text,
    resources jsonb null,
    CONSTRAINT plans_pkey PRIMARY KEY (id)
);
```

- `id`: Unique identifier for the plan
- `created_at`: Timestamp of when the plan was created
- `name`: Name of the plan
- `price`: Price of the plan
- `benefits`: JSON field describing plan benefits
- `description`: Text description of the plan
- `price_currency`: Currency of the plan price (default: 'euro')
- `stripe_price_id`: Stripe price ID for the plan
- `stripe_plan_id`: Stripe plan ID

### Customer-Plan Relationship Table

The `customer_plan` table manages the relationships between customers and plans.

```sql
CREATE TABLE public.customer_plan (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    customer_uuid uuid NOT NULL,
    plan_id bigint,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    resources jsonb null,
    CONSTRAINT customer_plan_pkey PRIMARY KEY (id),
    CONSTRAINT customer_plan_customer_uuid_fkey FOREIGN KEY (customer_uuid) REFERENCES public.customer(uuid) ON DELETE CASCADE,
    CONSTRAINT customer_plan_plan_id_fkey FOREIGN KEY (plan_id) REFERENCES public.plans(id) ON DELETE SET NULL
);
```

- `id`: Unique identifier for the relationship
- `customer_uuid`: Reference to the customer
- `plan_id`: Reference to the plan (can be NULL if the customer has no plan)
- `created_at`: Timestamp of when the relationship was created
- `updated_at`: Timestamp of when the relationship was last updated

## Indexes

Indexes are created to improve query performance:

```sql
CREATE INDEX idx_customer_plan_customer_uuid ON public.customer_plan(customer_uuid);
CREATE INDEX idx_customer_plan_plan_id ON public.customer_plan(plan_id);
```

## Functions and Triggers

### Handle New User

This function is triggered when a new user is created in the authentication system.

```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.customer (uuid, email, metadata, stripe_customer_id)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data, NULL);
  RETURN NEW;
END;
$$;

CREATE OR REPLACE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE PROCEDURE public.handle_new_user();
```

### Handle User Update

This function is triggered when a user's information is updated in the authentication system.

```sql
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE public.customer
  SET 
    metadata = NEW.raw_user_meta_data,
    email = NEW.email
  WHERE uuid = NEW.id;
  RETURN NEW;
end;
$$;

CREATE OR REPLACE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW
EXECUTE PROCEDURE public.handle_user_update();
```

## Usage

To use this schema:

1. Ensure you have PostgreSQL installed and running.
2. Create a new database or use an existing one.
3. Run the SQL commands provided in this README to create the tables, functions, and triggers.
4. The schema will automatically manage customer creation and updates based on the `auth.users` table.
5. You can manually insert data into the `plans` table as needed.
6. To associate a customer with a plan, insert a record into the `customer_plan` table.

## Notes

- This schema assumes the existence of an `auth.users` table for user authentication.
- The `stripe_customer_id` in the `customer` table and the Stripe-related fields in the `plans` table are prepared for integration with Stripe payment processing, but additional implementation would be needed to fully integrate with Stripe.
- Customers can exist without a plan, providing flexibility in your system.
- The `customer_plan` table allows for historical data of plan associations if needed.

### Policies

This Will Enable the RLS Policies

```sql
ALTER TABLE public.customer ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.customer_plan ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
```


## Complete SQL Code

For reference, here's the complete SQL code to set up this schema:

```sql
-- Create the plans table
CREATE TABLE public.plans (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text,
    price double precision,
    benefits jsonb NOT NULL,
    description text,
    price_currency text DEFAULT 'euro'::text,
    stripe_price_id text,
    stripe_plan_id text,
    CONSTRAINT plans_pkey PRIMARY KEY (id)
);

-- Create the customer table
CREATE TABLE public.customer (
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    uuid uuid NOT NULL,
    email character varying NOT NULL,
    metadata jsonb DEFAULT '[]'::jsonb,
    stripe_customer_id text,
    CONSTRAINT customer_pkey PRIMARY KEY (uuid),
    CONSTRAINT customer_uuid_fkey FOREIGN KEY (uuid) REFERENCES auth.users (id) ON DELETE CASCADE
);

-- Create the customer_plan relationship table
CREATE TABLE public.customer_plan (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    customer_uuid uuid NOT NULL,
    plan_id bigint,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    resources jsonb null,
    CONSTRAINT customer_plan_pkey PRIMARY KEY (id),
    CONSTRAINT customer_plan_customer_uuid_fkey FOREIGN KEY (customer_uuid) REFERENCES public.customer(uuid) ON DELETE CASCADE,
    CONSTRAINT customer_plan_plan_id_fkey FOREIGN KEY (plan_id) REFERENCES public.plans(id) ON DELETE SET NULL
);

-- Create indexes for better query performance
CREATE INDEX idx_customer_plan_customer_uuid ON public.customer_plan(customer_uuid);
CREATE INDEX idx_customer_plan_plan_id ON public.customer_plan(plan_id);

-- Create the handle_new_user function
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.customer (uuid, email, metadata, stripe_customer_id)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data, NULL);
  RETURN NEW;
END;
$$;

-- Create the on_auth_user_created trigger
CREATE OR REPLACE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE PROCEDURE public.handle_new_user();

-- Create the handle_user_update function
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE public.customer
  SET 
    metadata = NEW.raw_user_meta_data,
    email = NEW.email
  WHERE uuid = NEW.id;
  RETURN NEW;
end;
$$;

-- Create the on_auth_user_updated trigger
CREATE OR REPLACE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW
EXECUTE PROCEDURE public.handle_user_update();
```

Feel free to modify this README Content as needed for your specific project requirements.

In Order to Drop these , Use These Commands 
````
-- Drop triggers first
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Drop functions
DROP FUNCTION IF EXISTS public.handle_user_update();
DROP FUNCTION IF EXISTS public.handle_new_user();

-- Drop indexes
DROP INDEX IF EXISTS public.idx_customer_plan_plan_id;
DROP INDEX IF EXISTS public.idx_customer_plan_customer_uuid;

-- Drop tables
-- Note: Order is important due to foreign key constraints
DROP TABLE IF EXISTS public.customer_plan;
DROP TABLE IF EXISTS public.plans;
DROP TABLE IF EXISTS public.customer;
````
